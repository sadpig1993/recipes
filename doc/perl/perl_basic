Chapter 1 概述
    1. 在Perl中不必事先定义一个变量是什么类型的变量，在perl从，$test告诉perl，test是一个标量，也就是包含单个值的变量。与此对应的数组变量使用@开头。（可将$理解成"s" 或 "scalar"标量，而@表示"a" 或 "array" 数组帮助记忆。 Perl还有"散列(hash)", "句柄(handle)",  "typeglob"等其他一些变量类型，与标量和数组一样，这些变量也是前置一些趣味字符。

    perl中的标量可以赋值为整数，浮点数，字符串，甚至指向其他变量或对象的引用这样深奥的东西。与unix中的shell编程类似，可以使用不同的引号来获得不同的值，双引号进行变量内插(variable interpolation)和反斜杠内插(backslash interpolation)(比如把\n转成换行符)，单引号取消内插。而反引号(``)将执行外部程序并返回程序的输出，且将其赋值给变量。(进程替换)

    perl有两种类型的多值变量：数组和散列(hash)，在很多方面，它们和标量很相似，比如它们也会在需要时自动存在；但是，当你给它们赋值时，它们和标量就不一样了。它们在赋值等式右边提供列表(list)环境而不是标量环境。

    数组和散列也不相同，当你想通过编号来查找东西时，需要用数组，而如果你想通过名称来查找东西，那么应该用散列，这两种概念是互补的。数组是多个标量的有序列表，可以用标量在列表中的位置来访问其中的标量，列表中可以包含数字，字符串或同时包含两者；要对一个数组赋值，只需简单地将这些值排列在一起，并用大括号括起来：

    my @home = ("couch", "chair", "table", "stove");
    
    相反，如果在列表环境中使用@home，例如在一个列表赋值的右边，那么你将得到与你放进数组时同样的列表。所以可用如下所示从数组给四个标量赋值：
    my ($potato, $lift, $tennis, $pips) = @home ;
    和在C语言中一样，数组是以0开始计数的，可以用索引0到3来表示数组的第1个到第4个元素。如$home[n],这里n是脚标(索引)

    散列是一组无序标量，可以通过和每个标量关联的字符串进行访问，因为此原因，散列经常被称为关联数组(associative array)。
    my %longday = ( 
            "sun"   => "sunday",
            "mon"   => "monday",
            "tue"   => "tuesday",
            "wed"   => "wednesday",
            "thu"   => "thursday",
            "fri"   => "friday",
            "sat"   => "saturday",
             ) ;
     散列是一种特殊的数组，可以通过{}来获取单个的散列元素，比如你想找出与键wed对应的值，应该使用$longday{"wed"}。注意：因为是在处理标量，因此在longday前面使用$，而不是%，%代表整个散列。

    2. perl中的操作符，perl内置的操作符可以根据操作的数目分为一元，二元和三元操作符，也可以根据操作符的位置分为前缀(放在操作数前面)和中缀操作符(在操作数中间)以及后缀操作符(在操作数后面)。

    二元算术操作符  ：  +(加)   -(减)  *(乘)   /(除)   %(模)   **(幂)

    字符串操作符    ：  .(.操作符完成字符串的连接)  x(字符串的乘号，重复操作符)
    如 $a = 123;
       $b = 3 ;
       print $a * $b ;      # 打印369
       print $a x $b ;      # 打印123123123

    赋值操作符      ： 可以将=理解为"设为"而不是"等于"(数学等于操作符==才表示等于。 ==操作符相当于一个返回布尔值的函数，而=则相当于一个用于修改变量值的过程)。

    一元算术操作符  ： ++(自增) --(自减)

    逻辑操作符,也称为"短路(short-circuit)"操作符，允许程序不使用嵌套if语句，而根据多个条件来决定执行流程，它们之所以被称为"短路"操作符，是因为当认为左边的参数能够提供足够的信息来决定整个值时，它们将跳过(短路)执行右边的参数，这不仅仅是为了提高效率，可以依靠这种"短路"特性来避免执行为左边代码做防护(guarding)的右边的代码。
    例子        名字        结果
    ---------------------------------------------------------------
    $a && $b    与      如果$a为假，则为$a, 否则为$b
    $a || $b    或      如果$a为真，则为$a, 否则为$b
    ! $a        非      如果$a为假，则为真

    $a and $b   与      如果$a为假，则为$a, 否则为$b
    $a or  $b   或      如果$a为真，则为$a, 否则为$b
    not $a      非      如果$a为假，则为真
    $a xor $b  异或     如果$a或$b为真，但不同时为真，则值为真

    比较操作符告诉我们两个标量值(数字或字符串)之间的比较关系，这里有两组关系比较操作符，一组用于数字比较，另一组用于字符串比较(两组操作符都要求所有的参数都必须先转换成合适的类型)，假设两个参数是$a和$b，我们可以：
    比较            数字    字符串      返回值
    -------------------------------------------------------------------
    等于            ==      eq          如果$a等于$b,返回真
    不等于          !=      ne          如果$a不等于$b，返回真 
    小于            <       lt          如果$a小于$b, 返回真
    大于            >       gt          如果$a大于$b, 返回真
    小于或等于      <=      le          如果$a不大与$b，返回真
    大于或等于      >=      ge          如果$a不小于$b, 返回真
    比较           <=>     cmp          相等是为0,$a大则为1，$b大则为-1

    文件测试操作符
    例子           名字         结果
    -----------------------------------------------------------------
    -e $a           存在        如果在$a中命名的文件存在，则为真
    -r $a           可读        如果在$a中命名的文件可读，则为真
    -w $a           可写        如果在$a中命名的文件可写，则为真
    -d $a           目录        如果在$a中命名的文件是目录，则为真
    -f $a           文件        如果在$a中命名的文件是普通文件，则为真
    -T $a         文本文件      如果在$a中命名的文件是文本文件，则为真

    3. 控制结构。在perl中，真总是在标量环境中处理，除此之外没有任何的类型强制要求。下面是标量可以表示的不同种类的真值：
        1). 除""和"0"外，所有字符串为真
        2). 除0外，所有数字为真
        3). 所有引用为真
        4). 所有未定义的值为假

    if和unless语句。if语句计算真假条件(布尔表达式),并在条件为真时执行一个代码段，代码段是由一对大括号括在一起的一些语句。在C语言中，如果代码段中只有一条语句，那么可以省略大括号，但是在perl中，大括号是必需的。
    if ( condatation1 ) {
        # block 1
    }
    elsif ( condatation2 ) {
        # block 2
    }
    elsif ( condatation3 ) {
        # block 3
    }
    else {
        # block 4
    }
   
   有时候，你可能希望在条件为假时执行代码块，而不想在条件为真时执行任何代码，这就像在英语中说"如果这不是真的，就做某事"一样古怪，在这种情况下，可以使用unless语句：
   unless ( condatation ) { # 如果condatation 为假，则执行下面的代码块
        # execute block
   }

   循环结构,perl有四种循环语句的类型：while, until ,for和foreach。这些语句可以允许perl程序重复执行同一些代码。

   while和until语句，除了重复执行代码段之外，while和until语句之间的关系就像if和unless的关系一样。首先，检查条件部分，如果条件满足(while语句是真，until是假)，执行下面的代码段，例如：
   while ( $tickets_sold < 1000 ) { 
        $available = 1000 - $tickets_sold ;
        print "$available tickets are available. How many would you like: ";
        $purchase=<STDIN> ;
        chomp($purchase);
        $tickets_sold += $purchase ;
   }
   注意：如果没满足最初的条件，根本不会进入循环。

   for语句，for循环和while循环非常相似，但是看起来有很多不同之处。
   for ( $sold = 0 ; $sold < 1000 ; $sold += $purchase ) {
        $available = 1000 - $tickets_sold ;
        print "$available tickets are available. How many would you like: ";
        $purchase=<STDIN> ;
        chomp($purchase);
        $tickets_sold += $purchase ;
   }
   for循环在小括号中有3个表达式：一个表达式设置循环变量的初始状态，一个对循环变量进行条件判断，还有一个表达式修改循环变量的状态。

   foreach语句，perl中最后的一种循环语句是foreach语句，用来针对一组标量中的每一个标量运行同一段程序，例如：
   foreach my $user ( @users ) {
        if ( -f "$home($user)/.nexrc" ) {
            print "$user is cool ... they user a perl-aware vi!\n";
        }
   }
   不同与if和while语句，foreach的条件表达式实在列表环境，而不是标量环境中，因此表达式用于生成一个列表(即使列表中只有一个标量)。

   跳出控制结构：next和last，next操作符允许跳指本次循环的结束，开始下一个循环；last操作符允许跳至整个循环的结束，如同循环条件表达式为假时发生的情况一样。

   4. 正则表达式(regular expression, regexes, regexps, res)。perl定义了下面一些简写的方式:
   名字             ASCII定义                   代码
   -------------------------------------------------------------------
   空白            [\t\r\n\f]                   \s
   词字符          [a-zA-Z_0-9]                 \w
   数字            [0-9]                        \d
   -------------------------------------------------------------------
   注意这些简写都只匹配单个(single)字符，比如一个\w可匹配任何单个字符，而不是整个词。在perl中，这些通配符的大写方式代表的意思和小写方式刚好相反。例如：\D表示非数字字符。
   还有一种非常特别的字符类型，用"."来表示，可匹配所有的字符。

   量词，刚才我们讨论的字符和字符类都只能匹配单个字符，我们提到过可以用\w+来匹配多个"单词"字符，这里+就是量词。
   名字                     含义
   ------------------------------------------------
   {m,n}                  匹配至少m次，至多n次
   {m}                    匹配m次
   {m,}                   匹配至少m次
   +                      匹配1次或多次 ，等价 {1,}
   *                      匹配0次或多次 ，等价 {0,}
   ?                      匹配0次或1次  ，等价 {0,1}

   对量词而言，需要注意以下问题：
    1). 在默认状态下，perl量词都是贪婪的，也就是它们将尽可能多地匹配一个字符串中最大数量的字符，例如，如果使用/\d+/来匹配字符串"1234567890"，那么正则表达式将匹配整个字符串。使用"."时特别需要注意，例如下面一个字符串：
    larry:jyhtpho./njtu:100:10:Larry Wall:/home/larry:/bin/tcsh
并且想用/.+:/来匹配"larry:"，但是因为+是贪婪的，这个模式将匹配一直到/home/larry:为止。因为它尽可能多地匹配，直到最后出现的一个冒号为止。
    
    最小匹配。在新版本的perl中，可以强制进行非贪婪匹配。在量词后面加上一个问号来表示最小匹配。我们同样的用户名匹配就可以写成/.*?:/，这里.*?现在会尽可能少地匹配字符，而不是尽可能多地匹配字符，所以它将停止在第一个冒号而不是最后一个冒号的地方。

   反向引用，我们曾提到过可以用小括号来为量词包围一些字符，同样，也可以使用小括号来记住匹配到的东西。正则表达式中的一对小括号使得这部分匹配到的东西将被记住，以供以后使用。它不会改变匹配的方式，因此/\d+/和/(\d+)/仍然会尽可能多地匹配数字，但后边的匹配写法能够把匹配到的数字保存到一个特殊变量中，以供以后反向引用(backreference)。 


Chapter 2 细节
    1. 内置的数据类型。perl的3种基本数据类型是:标量，标量数组(array)和标量散列(hash)(也称为关联数组,assocaitive array)。变量总是这三种类型之一。(除变量外，还有一些其他的Perl抽象概念也可以认为是数据类型，比如文件句柄，目录句柄，格式，子例程，符号表和符号表记录等。)

        1). 标量是建造更复杂类型的基本类型。标量存储单一的简单值--通常是一个字符串或者一个数字。这种简单类型的元素可以组成两种聚集类型的任何一种

        2). 数组是标量的有序排列，可以通过一个整形脚标(或者索引)来访问，perl中的所有索引都是从0开始，不过和许多编程语言不一样，perl认为负数脚标也是合法的，负数脚标是从后向前计数数组。(这一点对许多子字符串和子列表操作符以及正则表达式都适用)

        3). 散列数组是一个无序的键/值对(key/value)对，可以用字符串(就是键,key)当作脚标来访问对应一个键的标量(就是值)。
 
    2. 变量，有3中变量类型和我们前面提到的3种抽象数据类型相对应。每种类型都由我们称为趣味字符(funny character)的字符做前缀($,@,%)。
    构造                            含义
    -------------------------------------------------
    $days                         简单标量值$days
    $days[28]                     数组@days 的第29个元素
    $days{'Feb'}                  散列%days 的"Feb"值

    请注意，我们可以对$days, @days和%days使用相同的名字，而不用担心perl会混淆它们。
   还有其他一些爱好者使用的标量术语，它们是：
   构造                             含义
   --------------------------------------------------------------------
   ${days}                     和$days 一样，不过在字母数字前面不易混淆
   $Dog::days                  在Dog包里的不同的$days 变量
   $#days                      数组@days 的最后一个元素的索引
   $days->[28]                 $days 引用指向的数组的第29个元素
   $days[0][2]                 多维数组
   $days{200}{'Feb'}           多维散列
   $days{2000,'Feb'}           多维散列仿真(emulation)

   整个数组(或者数组和散列的片段slice)带趣味字符@命名，很像单词"these"或"those"的作用:
   构造                             含义
   ---------------------------------------------------------------------
    @days                 包含($days[0], $days[1], ... $days[n])的数组 
    @days[3,4,5]          包含($days[3], $days[4], $days[5])的数组片段
    @days[3..5]           包含($days[3], $days[4], $days[5])的数组片段 
    @days{'jan','Feb'}    包含($days{'jan'}, $days{'Feb'})的散列片段

    每个散列都用%命名：
    构造                            含义
    -------------------------------------------------------------------
    %days                (jan=>31, Feb=>$leap?29:28, ...)

    3. 名字，变量本身需要存储在某个位置，在抽象概念中，这些地方被称为名字空间(namespace)。Perl提供两种类型的名字空间，通常称为符号表(symbol table)和词法作用域(lexical scope)，你可以拥有任意数量的符号表和词法作用域，但是你定义的任何名字都将存储在其中的某一个中。目前我们只能说符号表是全局散列，用于存储存放全局变量的符号表的记录(包括用于其他符号表的散列)，相比之下，词法作用域只是未命名的(unnamed）中间结果暂存器，不会存在于任何符号表，只是附着在程序的一块代码后面，他们包含只能被该块所见的变量。
     perl中符号表也被称包，因此这些变量常被称为包变量。包变量名义上是所属包的私有成员，但实际上是全局的，因为包本身就是全局的，也就是说，任何人都可以命名包以获取该变量。

    4. 名字查找。下面是在一定的环境里，Perl解析器为了理解一个未限定名字时用到的规则：
        1). 首先，Perl预先在最先结束的块里面查找，看看该变量是否有用my(或our)定义在该代码块里，如果存在my定义，那么该变量是词法作用域内的而不存在任何包里--它只存在与那个词法作用域里，那块程序之外的任何人甚至都看不到你的变量
        2). 如果上面的过程失败，Perl会尝试在包围该代码段的块里查找，仍然实在这个更大的代码块里查找词法作用域的变量。同样，如果Perl找到一个，那么就像我们刚在第一步说到的变量一样，该变量只属于从其定义开始到其定义块结束为止的词法作用域
        3). 当perl用光上层闭合块后，它将检查整个编译单元，把它当作代码块寻找声明(编译单元就是整个文件，或者被eval STRING 操作符编译过的当前字符串)。如果编译单位是一个文件，那就是最大的词法作用域，这样perl将不再查找词法作用域变量，于是进入第4步。

    
    5. 选择自己的引起字符。尽管我们认为引起字符是直接量值，但在Perl中，它们的作用更像操作符，提供了多种内插和模式匹配功能。Perl为这些操作提供了常用了引起字符，还提供了更通用的定制方法，让你可以为上面的任意操作选择你自己的引起字符。在下面表中，任意非字母数字，非空白定界符都可以放在/的为止(换行符和空格字符不再允许做定界符)
    表2-3  引起构造

    常用            通用                含义                  可否内插
    -----------------------------------------------------------------
    ''             q//                 直接量字符串             否
    ""            qq//                 直接量字符串             是
    ``            qx//                 执行命令                 是
    ( )           qw//                 单词列表                 否 
    //            m//                  模式匹配                 是
    s///          s///                 模式替换                 是
    y///          tr///                字符转换                 否
    "  "          qr//                 正则表达式               是
    -----------------------------------------------------------------

    6. "此处"文档(here-document)
    7. 命令输入(反引号)操作符。如$info = `finger $user` ; 一个用反引号引起的字符串首先进行变量内插，就像用双引号引起的字符串一样，得到的结果然后被系统当作一个命令行，而且那个命令的输出会成为伪直接变量的值。
在标量环境里返回一个包含所有输出的字符串，在列表环境里，返回一列值，每行输出一个值。
    8. 行输入(尖角)操作符，最频繁使用的行输入操作符，也叫尖角操作符或者readline函数。
