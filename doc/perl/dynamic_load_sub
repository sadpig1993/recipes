动态子程序

我们把所有没有用sub some_name明确定义的子程序或直到运行时才存在的子程序称为"动态子程序"。perl非常灵活，能够在运行的时候指定需要运行的代码，甚至能够执行能生成代码的代码。

1. 把子程序当作数据使用
   我们可以把匿名子程序保存在变量中，它们在调用之前不会被运行，这种变量保存的是行为，不是值。(demo basic-arthimetic.pl, arthimetic_up1.pl)


2. 创建和替换具名子程序(有名函数)(creating and replacing named subroutines)
   把匿名子程序保存在一个变量里，其实匿名子程序只是typeglob的一个slot(槽,即typeglob的其中的一项而已)。当把匿名子程序赋值给一个typeglob的时候，perl会把它保存在CODE区，之后，我们可以像具名子程序那样使用它。

   如果需要替换其他模块中的某些代码，这个功能非常有用,往往我们不希望编辑别的模块，因此我们保持它不变，只替换掉需要修改的子程序即可，由于子程序保存在符号表中，我们可以使用完整的软件包路径来替换一个子程序(demo replace_sub.pl)

3. 符号引用(symbolic references)
   用一个匿名子程序替换一个合法子程序的定义，我们通过操作符号表来实现替换，现在我们开始扩展这个功能的使用范围。

   符号引用--也叫符号表的引用，是一种使用字符串来选择变量的名字的方式，它看起来像是在用一个反引用操作来访问变量。
    
    为了使用动态子程序，我们需要把子程序名字保存在一个变量中，然后把变量变成一个子程序。(demo symbolic_ref.pl)

4. 遍历子程序列表(lterating through subroutine lists)


