[精华] Perl 中的正则表达式
http://www.chinaunix.net 作者:deathcult  发表于：2009-03-12 11:21:21
【发表评论】 【查看原文】 【Perl讨论区】【关闭】

原文出自：
http://263.aka.org.cn/Lectures/002/Lecture-2.1.2/perl-reg.html

感谢AKA及作者。


9    Perl 中的正则表达式

正则表达式的三种形式 

正则表达式中的常用模式 

正则表达式的 8 大原则 

正则表达式是 Perl 语言的一大特色，也是 Perl 程序中的一点难点，不过如果大家能够很好的掌握他，就可以轻易地用正则表达式来完成字符串处理的任务，当然在 CGI 程序设计中就更能得心应手了。下面我们列出一些正则表达式书写时的一些基本语法规则。

--------------------------------------------------------------------------------

9.1 正则表达式的三种形式

      首先我们应该知道 Perl 程序中，正则表达式有三种存在形式，他们分别是：

      匹配：m/<regexp>;/ （还可以简写为 /<regexp>;/ ，略去 m）

      替换：s/<pattern>;/<replacement>;/

      转化：tr/<pattern>;/<replacemnt>;/

      这三种形式一般都和 =~ 或 !~ 搭配使用（其中 "=~" 表示相匹配，在整条语句中读作 does，"!~" 表示不匹配，在整条语句中读作 doesn't），并在左侧有待处理的标量变量。如果没有该变量和 =~ !~ 操作符，则默认为处理 $_ 变量中的内容。举例如下：

      $str = "I love Perl";

      $str =~ m/Perl/; # 表示如果在 $str 中发现 "Perl" 字符串，则返回 "1" 否则返回 "0"。

      $str =~ s/Perl/BASH/; # 表示将变量 $str 中的 "Perl" 字符串替换为 "BASH"，如果发生此替换则返回 "1"，否则返回 "0"。

      $str !~ tr/A-Z/a-z/; # 表示将变量 $str 中的所有大写字母转化为小写字母，如果转化发生了则返回 "0"，否则返回 "1"。


      另外还有：

      foreach (@array) { s/a/b/; } # 此处每次循环将从 @array 数组中取出一个元素存放在 $_ 变量中，并对 $_ 进行替换处理。

      while (<FILE>;) { print if (m/error/); } # 这一句稍微复杂一些，他将打印 FILE 文件中所有包含 error 字符串的行。

      Perl 的正则表达式中如果出现 () ，则发生匹配或替换后 () 内的模式被 Perl 解释器自动依次赋给系统 $1, $2 ...... 请看下面的例子：

      $string = "I love perl";

      $string =~ s/(love)/<$1>;/; # 此时 $1 = "love"，并且该替换的结果是将 $string 变为 "I <love>; perl"

      $string = "i love perl";

      $string =~ s/(i)(.*)(perl)/<$3>;$2<$1>;/; # 这里 $1 = "i"，$2 = " love "，$3 = "perl"，并且替换后 $string 变为 "<perl>; love <i>;"

      替换操作 s/<pattern>;/<replacement>;/ 还可以在末尾加上 e 或 g 参数，他们的含义分别为：

      s/<pattern>;/<replacement>;/g 表示把待处理字符串中所有符合 <pattern>; 的模式全部替换为 <replacement>; 字符串，而不是只替换第一个出现的模式。

      s/<pattern>;/<replacement>;/e 表示将把 <replacemnet>; 部分当作一个运算符，这个参数用的不多。

      比如下面的例子：

      $string = "i:love:perl";

      $string =~ s/:/*/; #此时 $string="i*love:perl";

      $string = "i:love:perl";

      $string =~ s/:/*/g; #此时 $string="i*love*perl"; 

      $string =~ tr/*/ /; #此时 $string="i love perl"; 

      $string = "www22cgi44";

      $string =~ s/(\d+)/$1*2/e; # (/d+)代表 $string 中的一个或多个数字字符，将这些数字字符执行 *2 的操作，因此最后 $string 变成了 "www44cgi88"。

      下面给出一个完整的例子：

      #!/usr/bin/perl

      print"请输入一个字符串!\n";

      $string = <STDIN>;; # <STIDN>;代表标准输入，会让使用者输入一字符串

      chop($string); # 将$string最后一个换行的字符\n删除掉

      if($string =~ /perl/){

      　　print("输入的字符串中有 perl 这个字符串!\n";

      }


      如果输入的字符串含有 perl 这个字符串的话，就会显示后面的提示信息。


9.2 正则表达式中的常用模式

       下面是正则表达式中的一些常用模式。

       /pattern/  结果  

       . 匹配除换行符以外的所有字符 

       x? 匹配 0 次或一次 x 字符串 

       x* 匹配 0 次或多次 x 字符串，但匹配可能的最少次数 

       x+ 匹配 1 次或多次 x 字符串，但匹配可能的最少次数 

       .* 匹配 0 次或一次的任何字符 

       .+ 匹配 1 次或多次的任何字符 

       {m} 匹配刚好是 m 个 的指定字符串 

       {m,n} 匹配在 m个 以上 n个 以下 的指定字符串 

       {m,} 匹配 m个 以上 的指定字符串 

       [] 匹配符合 [] 内的字符 

       [^] 匹配不符合 [] 内的字符 

       [0-9] 匹配所有数字字符 

       [a-z] 匹配所有小写字母字符 

       [^0-9] 匹配所有非数字字符 

       [^a-z] 匹配所有非小写字母字符 

       ^ 匹配字符开头的字符 

       $ 匹配字符结尾的字符 

       \d 匹配一个数字的字符，和 [0-9] 语法一样 

       \d+ 匹配多个数字字符串，和 [0-9]+ 语法一样 

       \D 非数字，其他同 \d 

       \D+ 非数字，其他同 \d+ 

       \w 英文字母或数字的字符串，和 [a-zA-Z0-9] 语法一样 

       \w+ 和 [a-zA-Z0-9]+ 语法一样 

       \W 非英文字母或数字的字符串，和 [^a-zA-Z0-9] 语法一样 

       \W+ 和 [^a-zA-Z0-9]+ 语法一样 

       \s 空格，和 [\n\t\r\f] 语法一样 

       \s+ 和 [\n\t\r\f]+ 一样 

       \S 非空格，和 [^\n\t\r\f] 语法一样 

       \S+ 和 [^\n\t\r\f]+ 语法一样 

       \b 匹配以英文字母,数字为边界的字符串 

       \B 匹配不以英文字母,数值为边界的字符串 

       a|b|c 匹配符合a字符 或是b字符 或是c字符 的字符串 

       abc 匹配含有 abc 的字符串 

       (pattern) () 这个符号会记住所找寻到的字符串，是一个很实用的语法。第一个 () 内所找到的字符串变成 $1 这个变量或是 \1 变量，第二个 () 内所找到的字符串变成 $2 这个变量或是 \2 变量，以此类推下去。  

       /pattern/i i 这个参数表示忽略英文大小写，也就是在匹配字符串的时候，不考虑英文的大小写问题。 

       \ 如果要在 pattern 模式中找寻一个特殊字符，如 "*"，则要在这个字符前加上 \ 符号，这样才会让特殊字符失效 


        下面给出一些例子：    


        范例 说明 

        /perl/ 找到含有 perl 的字符串 

        /^perl/ 找到开头是 perl 的字符串 

        /perl$/ 找到结尾是 perl 的字符串 

        /c|g|i/ 找到含有 c 或 g 或 i 的字符串 

        /cg{2,4}i/ 找到 c 后面跟着 2个到 4个 g ，再跟着 i 的字符串 

        /cg{2,}i/ 找到 c 后面跟着 2个以上 g ，再跟着 i 的字符串 

        /cg{2}i/ 找到 c 后面跟着 2个 g，再跟着 i 的字符串 

        /cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

        /cg+i/ 找到 c 后面跟着一个以上 g，再跟着 i 的字符串，如同/cg{1,}i/ 

        /cg?i/ 找到 c 后面跟着 0个或是 1个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 

        /c.i/ 找到 c 后面跟着一个任意字符，再跟着 i 的字符串 

        /c..i/ 找到 c 后面跟着二个任意字符，再跟着 i 的字符串 

        /[cgi]/ 找到符合有这三个字符任意一个的字符串 

        /[^cgi]/ 找到没有这三个字符中任意一个的字符串 

        /\d/ 找寻符合数字的字符，可以使用/\d+/来表示一个或是多个数字组成的字符串 

        /\D/ 找寻符合不是数字的字符，可以使用/\D+/来表示一个或是更多个非数字组成的字符串 

        /\*/ 找寻符合 * 这个字符，因为 * 在常规表达式中有它的特殊意思，所以要在这个特殊符号前加上 \ 符号，这样才会让这个特殊字符失效 

        /abc/i 找寻符合 abc 的字符串而且不考虑这些字符串的大小写 


9.3 正则表达式的八大原则

         　　如果在 Unix 中曾经使用过 sed、awk、grep 这些命令的话，相信对于 Perl 语言中的正则表达式(Regular Expression)不会感到陌生。Perl 语言由于有这个功能，所以对字符串的处理能力非常强。在Perl语言的程序中，经常可以看到正则表达式的运用，在 CGI 程序设计中也不例外。


         　　正则表达式是初学 Perl 的难点所在，不过只要一旦掌握其语法，你就可以拥有几乎无限的模式匹配能力，而且 Perl 编程的大部分工作都是掌握常规表达式。下面给大家介绍几条正则表达式使用过程中的 8 大原则。 


         　　正则表达式在对付数据的战斗中可形成庞大的联盟——这常常是一场战争。我们要记住下面八条原则：

         · 原则1：正则表达式有三种不同形式(匹配(m/ /)，替换(s/ / /eg)和转换(tr/ / /))。

         · 原则2：正则表达式仅对标量进行匹配( $scalar =~ m/a/; 可以工作; @array =~ m/a/ 将把@array作为标量对待，因此可能不会成功)。

         · 原则3：正则表达式匹配一个给定模式的最早的可能匹配。缺省时，仅匹配或替换正则表达式一次( $a = 'string string2'; $a =~ s/string/ /; 导致 $a = 'string 2')。

         · 原则4：正则表达式能够处理双引号所能处理的任意和全部字符( $a =~ m/$varb/ 在匹配前把varb扩展为变量；如果 $varb = 'a' $a = 'as'，$a =~ s/$varb/ /; 等价于 $a =~ s/a/ /; ，执行结果使 $a = " s" )。

         · 原则5：正则表达式在求值过程中产生两种情况：结果状态和反向引用： $a=~ m/pattern/ 表示 $a 中是否有子串 pattern 出现，$a =~ s/(word1)(word2)/$2$1/ 则“调换”这两个单词。

         · 原则6：正则表达式的核心能力在于通配符和多重匹配运算符以及它们如何操作。$a =~ m/\w+/ 匹配一个或多个单词字符；$a =~ m/\d/" 匹配零个或多个数字。

         · 原则7：如果欲匹配不止一个字符集合，Perl使用 "|" 来增加灵活性。如果输入 m/(cat|dog)/ 则相当于“匹配字符串 cat 或者 dog。

         · 原则8：Perl用 (?..) 语法给正则表达式提供扩展功能。（这一点请同学们课后看相关资料）

         想要学习所有这些原则？我建议大家先从简单的开始，并且不断的尝试和实验。实际上如果学会了 $a =~ m/ERROR/ 是在 $a 中查找子串ERROR，那么你就已经比在 C 这样的低层语言中得到了更大的处理能力。



          roby 回复于：2003-09-11 15:19:39

          good
          简洁明了
          但是原文中
          \w 英文字母或数字的字符串，和 [a-zA-Z0-9] 语法一样 
          这好象错了吧
          我记得应该还包括下划线,也就是[a-zA-Z_0-9]

          /cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,1}i/ 
          这句也笔误了
          应该是
          /cg*i/ 找到 c 后面跟着 0个或多个 g ，再跟着 i 的字符串，如同/cg{0,}i/  
