package

通常，package声明如果放在文件的第一条语句，意味着它将被require或者use导入(但这只是一个习惯)，你可以在任何可以放语句的地方放置package声明。你甚至可以把package声明放在块的结尾，只不过这个时候它将不起任何作用。你可以在一个以上的地方切换到包中，包声明的作用只是为该块其他部分选择将要使用的符号表。

我们可以引用其他包里的标志符，方法是用包名字和双冒号做前缀(双冒号起限定作用): $package::Variable。如果包名字为空，默认为main包，即$::sail等于$main::sail。

只有标识符(以字母或者下划线开头的名字)才存储在包的符号表中，所有其他符号都保存在main包中，包括所有非字母变量，如$! $? $_等。

%SIG散列(用于捕获信号，参见大骆驼16章)也是特殊的。如果你把一个信号处理器定义为字符串，那么perl就假设它引用main包里的一个子例程，除非明确地使用了其他包名字。如果想指定一个特定的包，那么你要使用一个信号处理器的全限定名称，或者完全避免字符串的使用：方法是改为赋予一个typeglob或者函数引用:(见下面的demo)
   $SIG{QUIT}  =   "$Pkg::quit_catcher";   #处理器全限定名称
   $SIG{QUIT}  =   "quit_catcher";         #隐含的"main::quit_catcher"
   $SIG{QUIT}  =   "*quit_catcher";        #强制为当前包的子例程(函数)
   $SIG{QUIT}  =   "\&quit_catcher";   #强制为当前包的子例程(函数)
   $SIG{QUIT}  =   sub { print "Caught SIGQUit\n" }; #匿名子例程


"当前包"的概念既是编译时的概念也是运行时的概念，大多数变量名查找发生在编译时，但是运行时查找发生在符号引用解引用时，以及eval解析新的代码时。实际上，你eval一个字符串时，perl知道该eval是哪个包里调用的，并且在计算该字符串时，把那个包名字传递到eval中。
