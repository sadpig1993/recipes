一、什么是多线程？

      当我自己提出这个问题的时候，我还是很老实的拿着操作系统的书，按着上面的话敲下“为了减少进程切换和创建开销，提高执行效率和节省资源，我们引入了线程的概念，与进程相比较，线程是CPU调度的一个基本单位。”

      形象点的举个例子说：一个WEB服务器可以同时接收来自不同用户的网页访问请求，显然服务器处理这些网页请求都是通过并发进行的否则将会造成用户等待时间长或者响应效率低等问题。如果在服务器中使用进程的办法来处理来自不同网页访问请求的话，我们可以用创建父进程以及多个子进程的方法，然而这样会花费很大的系统开销和占用较多的资源，因此这样会较大的限制了访问服务器的用户数量。

      使用多线程的理由之一是和进程相比，它是一种非常"节俭"的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间

      使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改

二、互斥锁

      正如上面所说的，如果两个线程同时对一块内存进行读写或者对向同一个文件写数据，那么结果是难以设想的。正因为如此，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。

 例如int *a  int *b  分别指向两块内存，上面的值分别初始化为（200， 100） 线程A执行这样的一个操作：将*a的值减少50，*b的值增加50.

 线程B执行：打印出（a 跟 b 指向的内存的值的和）。

      如果串行运行：A: *a -= 50; *b += 50;  B: printf("%d\n", *a + *b);  

      如果并发执行，则有可能会出现一下调度：*a -= 50; printf("%d\n", *a + *b); *b += 50;

      因此我们可以引入互斥量，在对共享数据读写时进行锁操作，实现对内存的访问以互斥的形式进行。
    
      参考  mutex.c
